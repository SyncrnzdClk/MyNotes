# leftist heap and skew heap

## constructing a leftist heap
我们发现二叉堆实际上也是一个左式堆，所以我们直接按照建立二叉堆的方式来建立左式堆即可，这是$O\left(n\right)$的复杂度

## deleting a key in leftist heap
给定一个中间节点的指针，我们要怎么去安全地删除这个节点并且不破坏左式堆的性质呢？

首先我们把该点为根的子树给拿到外面去，然后delete掉该点，就又得到两棵树。

现在的问题就是被挖去一部分的树要怎么修复左式堆的性质。那么其实也很简单，就直接在从根到原目标点（现在被挖掉了）的路径上从下至上地修复就行。修复的方法就是看到性质被破坏就交换左右儿子，然后更新npl（如果性质没被破坏也应该更新npl）。

那么问题来了，我们知道左式堆里面任意一条路径的长度不一定是$O\left(log (n) \right)$，那么删除是不是就变得可能很开销很大呢？实际上不是的，因为当我们在修复的过程中，如果遇到了 上一个被修复节点 在 当前被修复节点 的左边并且当前被修复节点的左式堆性质没有被破坏。这时候就可以停止啦！因为当前节点的npl没有改变，再往上的节点左式堆性质和npl也都不会改变。然后我们得到一个重要观察，也就是被修复节点全部都排在当前节点的右路径上（否则就是前面说的停止的情况），那么被修复的长度肯定是会在当前节点为根的子树的log节点数量的量级。

最后我们把之前产生的两棵子树和被修复的这棵树进行merge就行。

*remark*：decrease key操作和delete操作类似，无非就是把挖出来的子树的根的key去decrease一下，剩下操作基本相同。


